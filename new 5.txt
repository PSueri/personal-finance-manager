Esercizio 1:
 
TABELLA_ANAGRAFICA
ID_Cliente | Età | Coordinate_Zona_Geo
 
TABELLA_CONSUMI
ID_Contratto | Data | Consumo_energia
 
TABELLA_CONTRATTI
ID_Cliente | ID_Contratto | Tipo_Contratto | Data_Sottoscrizione | Data_Rinnovo | Prezzo_Fisso | Prezzo_Variabile
 
TABELLA_PREZZO_ENERGIA
Data | Prezzo_energia
 
TABELLA_PAGAMENTI
ID_Cliente | Data_Emissione_Fattura | Data_Pagamento_Fattura | Prezzo_Fattura | Flag_Ritardo_Pagamento
 
TABELLA_PREZZI_CONCORRENTI
ID_Concorrente |Data_Rilevazione_Prezzo | Prezzo_Fisso | Prezzo_Variable
 
Consegna: creare una tabella unica contenente le features + target label da dare in pasto ad un modello di churn detection (ad un anno).
 
 import pandas as pd

# Load data from tables
anagrafica_df = pd.read_csv('TABELLA_ANAGRAFICA.csv')
consumi_df = pd.read_csv('TABELLA_CONSUMI.csv')
contratti_df = pd.read_csv('TABELLA_CONTRATTI.csv')
prezzo_energia_df = pd.read_csv('TABELLA_PREZZO_ENERGIA.csv')
pagamenti_df = pd.read_csv('TABELLA_PAGAMENTI.csv')
prezzi_concorrenti_df = pd.read_csv('TABELLA_PREZZI_CONCORRENTI.csv')

# Merge tables based on common IDs
merged_df = anagrafica_df.merge(
    contratti_df[['ID_Cliente', 'ID_Contratto', 'Tipo_Contratto', 'Data_Sottoscrizione', 'Data_Rinnovo', 'Prezzo_Fisso', 'Prezzo_Variabile']],
    on='ID_Cliente', how='left')

merged_df = merged_df.merge(
    consumi_df[['ID_Contratto', 'Data', 'Consumo_energia']],
    on='ID_Contratto', how='left')

merged_df = merged_df.merge(
    prezzo_energia_df[['Data', 'Prezzo_energia']],
    left_on='Data',
    right_on='Data',
    how='left')

merged_df = merged_df.merge(
    pagamenti_df[['ID_Cliente', 'Data_Emissione_Fattura', 'Data_Pagamento_Fattura', 'Prezzo_Fattura', 'Flag_Ritardo_Pagamento']],
    on='ID_Cliente', how='left')

merged_df = merged_df.merge(
    prezzi_concorrenti_df[['ID_Concorrente', 'Data_Rilevazione_Prezzo', 'Prezzo_Fisso', 'Prezzo_Variable']],
    left_on='Data_Rilevazione_Prezzo',
    right_on='Data',
    how='left')

# Calculate churn target label
churn_label = []
for i in range(len(merged_df)):
    row = merged_df.iloc[i]
    if (row['Data_Rinnovo'] + pd.DateOffset(years=1)) < pd.to_datetime('today'):
        churn_label.append(1)  # Churned
    else:
        churn_label.append(0)  # Not churned

merged_df['Churn_Label'] = churn_label

# Select features and target label
features = ['Età', 'Coordinate_Zona_Geo', 'Tipo_Contratto', 'Data_Sottoscrizione', 'Prezzo_Fisso', 'Prezzo_Variabile',
           'Consumo_energia', 'Prezzo_energia', 'Data_Emissione_Fattura', 'Data_Pagamento_Fattura', 'Prezzo_Fattura',
           'Flag_Ritardo_Pagamento', 'Prezzo_Fisso_Concorrente', 'Prezzo_Variabile_Concorrente']
target = 'Churn_Label'

# Create single table for churn detection
churn_detection_df = merged_df[['ID_Cliente'] + features + [target]]

# Save the churn detection table
churn_detection_df.to_csv('churn_detection_data.csv', index=False)

--------------------------------------------------------------------------------------------------------------------------------------------------------
Esercizio 2:
 
TABELLA_MODELLO_OCT_PROD
ID_Cliente | Data_Ora_Contatto | Prob_Modello_OCT | Prob_Baseline
 
TABELLA_MODELLO_OCT_DEV
ID_Cliente | Data_Ora_Contatto | Prob_Modello_OCT | Prob_Baseline
 
Consegna: confrontare i risultati dei due modelli di assegnazione dello slot di contatto (Optimal Contact Time), dove 'Prob_Modello_OCT' è la proabilità di contatto secondo il modello, mentre 'Prob_Baseline' è la probabilità in assenza di modello (contatto random). Valutare se il modello in 'dev' è migliore di quello in 'prod'.
La coppia 'ID_Cliente' e 'Data_Ora_Contatto' è univoca in ognuna delle due tabelle.
 
 import pandas as pd

# Caricamento dati
data_prod = pd.read_csv("TABELLA_MODELLO_OCT_PROD.csv")
data_dev = pd.read_csv("TABELLA_MODELLO_OCT_DEV.csv")

# Unione tabelle
data = data_prod.merge(data_dev, on=["ID_Cliente", "Data_Ora_Contatto"], how="inner")

# Calcolo differenza di probabilità
data["Diff_Prob"] = data["Prob_Modello_OCT_DEV"] - data["Prob_Modello_OCT_PROD"]

# Calcolo miglioramento medio
miglioramento_medio = data["Diff_Prob"].mean()

# Test statistico (esempio con test t per campioni appaiati)
from scipy.stats import ttest_paired

tstat, pval = ttest_paired(data["Prob_Modello_OCT_PROD"], data["Prob_Modello_OCT_DEV"])

# Interpretazione risultati
if pval < 0.05:
    print(f"Il modello 'dev' migliora la probabilità di contatto rispetto al modello 'prod' con un miglioramento medio di {miglioramento_medio:.3f} (p-value = {pval:.5f}).")
else:
    print(f"Non vi è sufficiente evidenza per affermare che il modello 'dev' sia migliore del modello 'prod' (p-value = {pval:.5f}).")

--------------------------------------------------------------------------------------------------------------------------------------------------------
Esercizio 3:
 
TABELLA_MODELLO_OCT_ALL_COMBINATIONS
ID_Cliente | Data_Contatto | Ora_Contatto | Prob_Modello_OCT | Prob_Baseline
 
Consegna: in questo caso la tabella contiene per ogni 'ID_Cliente' tuttel e possibili combinazioni di 'Data_Contatto' e 'Ora_Contatto', oltre alla proabilità di contatto secondo il modello di OCT (specifica per ogni cliente e per ogni slot di contatto). Implementare un algoritmo in grado di assegnare ad ogni 'ID_Cliente' un'unica coppia 'Data_Contatto' e 'Ora_Contatto', considerando I seguenti vincoli:
•	In ogni slot orario (Data e Ora) possono essere assegnati un max di 100 clienti
•	In ogni slot orario (Data e Ora) possono essere assegnati un min di 50 clienti
import pandas as pd

# Caricamento dei dati in un DataFrame
df = pd.read_csv("TABELLA_MODELLO_OCT_ALL_COMBINATIONS.csv")

# Ordinamento dei dati in base a Prob_Modello_OCT in ordine decrescente
df_sorted = df.sort_values(by="Prob_Modello_OCT", ascending=False)

# Definizione dei vincoli
min_clienti_per_slot = 50
max_clienti_per_slot = 100

# Assegnazione degli appuntamenti
appuntamenti = {}
for index, row in df_sorted.iterrows():
    cliente_id = row["ID_Cliente"]
    data_contatto = row["Data_Contatto"]
    ora_contatto = row["Ora_Contatto"]

    # Identificazione dello slot di contatto corrente
    slot_corrente = (data_contatto, ora_contatto)

    # Verifica del numero di clienti nello slot corrente
    if slot_corrente not in appuntamenti:
        appuntamenti[slot_corrente] = 0
    numero_clienti_slot_corrente = appuntamenti[slot_corrente]

    # Assegnazione del cliente allo slot corrente se il numero di clienti è inferiore al minimo
    if numero_clienti_slot_corrente < min_clienti_per_slot:
        appuntamenti[slot_corrente] += 1
        assegnazione_cliente = (cliente_id, data_contatto, ora_contatto)
        print(f"Assegnazione: {assegnazione_cliente}")
        continue

    # Se lo slot corrente è pieno, controllo degli slot successivi
    slot_successivi = df_sorted.loc[index:].loc[:, ["Data_Contatto", "Ora_Contatto"]]
    for data_contatto_succ, ora_contatto_succ in slot_successivi.itertuples(index=False):
        slot_successivo = (data_contatto_succ, ora_contatto_succ)

        # Verifica del numero di clienti nello slot successivo
        if slot_successivo not in appuntamenti:
            appuntamenti[slot_successivo] = 0
        numero_clienti_slot_successivo = appuntamenti[slot_successivo]

        # Spostamento del cliente nello slot successivo se possibile
        if numero_clienti_slot_successivo < max_clienti_per_slot:
            appuntamenti[slot_corrente] -= 1
            appuntamenti[slot_successivo] += 1
            assegnazione_cliente = (cliente_id, data_contatto_succ, ora_contatto_succ)
            print(f"Assegnazione: {assegnazione_cliente}")
            break

        # Se tutti gli slot successivi sono pieni, il cliente non può essere schedulato
        if all(numero_clienti >= max_clienti_per_slot for numero_clienti in appuntamenti.values()):
            print(f"Impossibile assegnare: {cliente_id}")
            break

# Controllo finale: verifica che tutti i clienti abbiano un'assegnazione
if len(df_sorted) != len(appuntamenti):
    print("Attenzione: non tutti i clienti hanno un'assegnazione")

